# hw1 - Readiness Exercise
## Your name (UID)

### 1.
Explain why the output of the following code snippet is 0.
``` 
unsigned int i = 0;
printf("%u", i--);
```


[your answer]

Because we use a postfix decrement operator here so the value is printed first before the decrement.

### 2.

Explain why the output of the following code snippet is "char=1, int=4, long=8" in x86 (64-bit).

```
printf("char=%d, int=%d, long=%d", \
  sizeof(char), sizeof(int), sizeof(long));
```

[your answer]

Data type sizes are determined by the architecture, which are fixed in hardware.  In x86-64 we have:
1 byte => 8 bits
word=2 bytes
int=4 bytes
long=8 bytes

### 3.
Explain why the output of the following code snippet is "st0 = 8, st1 = 8".

```
struct st0 {
  int x;
  char y;
};
struct st1 {
  int x;
  char y;
  char z;
};
int main()
{
  printf("st0 = %d, st1 = %d\n",
  sizeof(struct st0), sizeof(struct st1));
}
```

[your answer]

```
robertdavidhernandez@MacBook-Pro:~/code/cs_594 (main) > gcc hello.c
hello.c:17:5: warning: format specifies type 'int' but the argument has type 'unsigned long' [-Wformat]
    sizeof(struct st0), sizeof(struct st1));
    ^~~~~~~~~~~~~~~~~~
hello.c:17:25: warning: format specifies type 'int' but the argument has type 'unsigned long' [-Wformat]
    sizeof(struct st0), sizeof(struct st1));
                        ^~~~~~~~~~~~~~~~~~
2 warnings generated.
```

It would seem to be based on the compiler output that the reason the sizes of the structs are the same is because the underlying data structures are "unsigned long", it would seem that one of (compiler, hardware, OS kernel) assign an unsigned long as the minimun size for a struct.

### 4.

### 5.

### 6.

### 7.

### 8.

### 9.
![](hw1_tux_1234567.png)
